{
  "_args": [
    [
      {
        "raw": "bfj-node4@^5.2.0",
        "scope": null,
        "escapedName": "bfj-node4",
        "name": "bfj-node4",
        "rawSpec": "^5.2.0",
        "spec": ">=5.2.0 <6.0.0",
        "type": "range"
      },
      "C:\\Users\\mrfksiv\\Documents\\Projects\\shapp_new\\node_modules\\webpack-bundle-analyzer"
    ]
  ],
  "_from": "bfj-node4@>=5.2.0 <6.0.0",
  "_id": "bfj-node4@5.2.1",
  "_inCache": true,
  "_location": "/bfj-node4",
  "_nodeVersion": "8.9.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/bfj-node4_5.2.1_1518249326333_0.11429372754655698"
  },
  "_npmUser": {
    "name": "philbooth",
    "email": "pmbooth@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "bfj-node4@^5.2.0",
    "scope": null,
    "escapedName": "bfj-node4",
    "name": "bfj-node4",
    "rawSpec": "^5.2.0",
    "spec": ">=5.2.0 <6.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/webpack-bundle-analyzer"
  ],
  "_resolved": "https://registry.npmjs.org/bfj-node4/-/bfj-node4-5.2.1.tgz",
  "_shasum": "3a6aa2730cf6911ba2afb836c2f88f015d718f3f",
  "_shrinkwrap": null,
  "_spec": "bfj-node4@^5.2.0",
  "_where": "C:\\Users\\mrfksiv\\Documents\\Projects\\shapp_new\\node_modules\\webpack-bundle-analyzer",
  "author": {
    "name": "Phil Booth",
    "url": "https://github.com/philbooth"
  },
  "bugs": {
    "url": "https://github.com/philbooth/bfj/issues"
  },
  "contributors": [
    {
      "name": "Phil Booth",
      "email": "pmbooth@gmail.com",
      "url": "https://github.com/philbooth"
    },
    {
      "name": "Rowan Manning",
      "url": "https://github.com/rowanmanning"
    },
    {
      "name": "Benedikt RÃ¶tsch",
      "url": "https://github.com/axe312ger"
    }
  ],
  "dependencies": {
    "bluebird": "^3.5.1",
    "check-types": "^7.3.0",
    "tryer": "^1.0.0"
  },
  "description": "Big-friendly JSON. Asynchronous streaming functions for large JSON data sets.",
  "devDependencies": {
    "chai": "4.1.x",
    "eslint": "4.17.x",
    "mocha": "5.0.x",
    "please-release-me": "2.0.x",
    "proxyquire": "1.8.x",
    "request": "2.83.x",
    "spooks": "2.0.x"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-w+OTPD/R0AvDVR/sy/uVUVeoCpEgUoYj9/1P2zB6mR1yx7F/ADzLX4nlvZ/91WWzGgdZnuLxWP/J89D7ZDt0DA==",
    "shasum": "3a6aa2730cf6911ba2afb836c2f88f015d718f3f",
    "tarball": "https://registry.npmjs.org/bfj-node4/-/bfj-node4-5.2.1.tgz",
    "fileCount": 34,
    "unpackedSize": 282228
  },
  "engines": {
    "node": ">= 4.0.0"
  },
  "gitHead": "c7800e262f1d87f1419e5e536cdd66ca4ac730aa",
  "homepage": "https://github.com/philbooth/bfj",
  "keywords": [
    "json",
    "streamify",
    "stringify",
    "walk",
    "parse",
    "parser",
    "serialise",
    "serialize",
    "read",
    "write",
    "async",
    "asynchronous"
  ],
  "license": "MIT",
  "main": "./src",
  "maintainers": [
    {
      "name": "philbooth",
      "email": "pmbooth@gmail.com"
    }
  ],
  "name": "bfj-node4",
  "optionalDependencies": {},
  "readme": "# BFJ\n\n[![Package status](https://img.shields.io/npm/v/bfj.svg?style=flat-square)](https://www.npmjs.com/package/bfj)\n[![Build status](https://img.shields.io/travis/philbooth/bfj.svg?style=flat-square)](https://travis-ci.org/philbooth/bfj)\n[![License](https://img.shields.io/github/license/philbooth/bfj.svg?style=flat-square)](https://opensource.org/licenses/MIT)\n\nBig-Friendly JSON. Asynchronous streaming functions for large JSON data sets.\n\n* [Why would I want those?](#why-would-i-want-those)\n* [Is it fast?](#is-it-fast)\n* [What functions does it implement?](#what-functions-does-it-implement)\n* [How do I install it?](#how-do-i-install-it)\n* [How do I read a JSON file?](#how-do-i-read-a-json-file)\n* [How do I write a JSON file?](#how-do-i-write-a-json-file)\n* [How do I parse a stream of JSON?](#how-do-i-parse-a-stream-of-json)\n* [How do I create a JSON string?](#how-do-i-create-a-json-string)\n* [How do I create a stream of JSON?](#how-do-i-create-a-stream-of-json)\n* [What other methods are there?](#what-other-methods-are-there)\n  * [bfj.walk (stream, options)](#bfjwalk-stream-options)\n  * [bfj.eventify (data, options)](#bfjeventify-data-options)\n* [What options can I specify?](#what-options-can-i-specify)\n  * [Options for parsing functions](#options-for-parsing-functions)\n  * [Options for serialisation functions](#options-for-serialisation-functions)\n* [Why does it default to bluebird promises?](#why-does-it-default-to-bluebird-promises)\n* [Can I specify a different promise implementation?](#can-i-specify-a-different-promise-implementation)\n* [Is there a change log?](#is-there-a-change-log)\n* [How do I set up the dev environment?](#how-do-i-set-up-the-dev-environment)\n* [What versions of Node.js does it support?](#what-versions-of-nodejs-does-it-support)\n* [What license is it released under?](#what-license-is-it-released-under)\n\n## Why would I want those?\n\nIf you need\nto parse huge JSON strings\nor stringify huge JavaScript data sets,\nit monopolises the event loop\nand can lead to out-of-memory exceptions.\nBFJ implements asynchronous functions\nand uses pre-allocated fixed-length arrays\nto try and alleviate those issues.\n\n## Is it fast?\n\nNo.\n\nBFJ yields frequently\nto avoid monopolising the event loop,\ninterrupting its own execution\nto let other event handlers run.\nThe frequency of those yields\ncan be controlled with the [`yieldRate` option](#what-options-can-i-specify),\nbut fundamentally it is not designed for speed.\n\nFurthermore,\nwhen serialising data to a stream,\nBFJ uses a fixed-length buffer\nto avoid exhausting available memory.\nWhenever that buffer is full,\nserialisation is paused\nuntil the receiving stream processes some more data,\nregardless of the value of `yieldRate`.\nYou can control the size of the buffer\nusing the [`bufferLength` option](#options-for-serialisation-functions)\nbut really,\nif you need quick results,\nBFJ is not for you.\n\n## What functions does it implement?\n\nEight functions\nare exported.\n\nFour are\nconcerned with\nparsing, or\nturning JSON strings\ninto JavaScript data:\n\n* [`read`](#how-do-i-read-a-json-file)\n  asynchronously parses\n  a JSON file from disk.\n\n* [`parse` and `unpipe`](#how-do-i-parse-a-stream-of-json)\n  are for asynchronously parsing\n  streams of JSON.\n\n* [`walk`](#bfjwalk-stream-options)\n  asynchronously walks\n  a stream,\n  emitting events\n  as it encounters\n  JSON tokens.\n  Analagous to a\n  [SAX parser][sax].\n\nThe other four functions\nhandle the reverse transformations,\nserialising\nJavaScript data\nto JSON:\n\n* [`write`](#how-do-i-write-a-json-file)\n  asynchronously serialises data\n  to a JSON file on disk.\n\n* [`stringify`](#how-do-i-create-a-json-string)\n  asynchronously serialises data\n  to a JSON string.\n\n* [`streamify`](#how-do-i-create-a-stream-of-json)\n  asynchronously serialises data\n  to a stream of JSON.\n\n* [`eventify`](#bfjeventify-data-options)\n  asynchronously traverses\n  a data structure\n  depth-first,\n  emitting events\n  as it encounters items.\n  By default\n  it coerces\n  promises, buffers and iterables\n  to JSON-friendly values.\n\n## How do I install it?\n\nIf you're using npm:\n\n```\nnpm i bfj --save\n```\n\nOr if you just want\nthe git repo:\n\n```\ngit clone git@github.com:philbooth/bfj.git\n```\n\n## How do I read a JSON file?\n\n```js\nconst bfj = require('bfj');\n\nbfj.read(path, options)\n  .then(data => {\n    // :)\n  })\n  .catch(error => {\n    // :(\n  });\n```\n\n`read` returns a [bluebird promise][promise] and\nasynchronously parses\na JSON file\nfrom disk.\n\nIt takes two arguments;\nthe path to the JSON file\nand an [options](#options-for-parsing-functions) object.\n\nIf there are\nno syntax errors,\nthe returned promise is resolved\nwith the parsed data.\nIf syntax errors occur,\nthe promise is rejected\nwith the first error.\n\n## How do I write a JSON file?\n\n```js\nconst bfj = require('bfj');\n\nbfj.write(path, data, options)\n  .then(() => {\n    // :)\n  })\n  .catch(error => {\n    // :(\n  });\n```\n\n`write` returns a [bluebird promise][promise]\nand asynchronously serialises a data structure\nto a JSON file on disk.\nThe promise is resolved\nwhen the file has been written,\nor rejected with the error\nif writing failed.\n\nIt takes three arguments;\nthe path to the JSON file,\nthe data structure to serialise\nand an [options](#options-for-serialisation-functions) object.\n\n## How do I parse a stream of JSON?\n\n```js\nconst bfj = require('bfj');\n\n// By passing a readable stream to bfj.parse():\nbfj.parse(fs.createReadStream(path), options)\n  .then(data => {\n    // :)\n  })\n  .catch(error => {\n    // :(\n  });\n\n// ...or by passing the result from bfj.unpipe() to stream.pipe():\nrequest({ url }).pipe(bfj.unpipe((error, data) => {\n  if (error) {\n    // :(\n  } else {\n    // :)\n  }\n}))\n```\n\n* `parse` returns a [bluebird promise][promise]\n  and asynchronously parses\n  a stream of JSON data.\n\n  It takes two arguments;\n  a [readable stream][readable]\n  from which\n  the JSON\n  will be parsed\n  and an [options](#options-for-parsing-functions) object.\n\n  If there are\n  no syntax errors,\n  the returned promise is resolved\n  with the parsed data.\n  If syntax errors occur,\n  the promise is rejected\n  with the first error.\n\n* `unpipe` returns a [writable stream][writable]\n  that can be passed to [`stream.pipe`][pipe],\n  then parses JSON data\n  read from the stream.\n\n  It takes two arguments;\n  a callback function\n  that will be called\n  after parsing is complete\n  and an [options](#options-for-parsing-functions) object.\n\n  If there are no errors,\n  the callback is invoked\n  with the result as the second argument.\n  If errors occur,\n  the first error is passed\n  the callback\n  as the first argument.\n\n## How do I create a JSON string?\n\n```js\nconst bfj = require('bfj');\n\nbfj.stringify(data, options)\n  .then(json => {\n    // :)\n  })\n  .catch(error => {\n    // :(\n  });\n```\n\n`stringify` returns a [bluebird promise][promise] and\nasynchronously serialises a data structure\nto a JSON string.\nThe promise is resolved\nto the JSON string\nwhen serialisation is complete.\n\nIt takes two arguments;\nthe data structure to serialise\nand an [options](#options-for-serialisation-functions) object.\n\n## How do I create a stream of JSON?\n\n```js\nconst bfj = require('bfj');\n\nconst stream = bfj.streamify(data, options);\n\n// Get data out of the stream with event handlers\nstream.on('data', chunk => { /* ... */ });\nstream.on('end', () => { /* ... */);\nstream.on('dataError', () => { /* ... */);\n\n// ...or you can pipe it to another stream\nstream.pipe(someOtherStream);\n```\n\n`streamify` returns a [readable stream][readable]\nand asynchronously serialises\na data structure to JSON,\npushing the result\nto the returned stream.\n\nIt takes two arguments;\nthe data structure to serialise\nand an [options](#options-for-serialisation-functions) object.\n\n## What other methods are there?\n\n### bfj.walk (stream, options)\n\n```js\nconst bfj = require('bfj');\n\nconst emitter = bfj.walk(fs.createReadStream(path), options);\n\nemitter.on(bfj.events.array, () => { /* ... */ });\nemitter.on(bfj.events.object, () => { /* ... */ });\nemitter.on(bfj.events.property, name => { /* ... */ });\nemitter.on(bfj.events.string, value => { /* ... */ });\nemitter.on(bfj.events.number, value => { /* ... */ });\nemitter.on(bfj.events.literal, value => { /* ... */ });\nemitter.on(bfj.events.endArray, () => { /* ... */ });\nemitter.on(bfj.events.endObject, () => { /* ... */ });\nemitter.on(bfj.events.error, error => { /* ... */ });\nemitter.on(bfj.events.end, () => { /* ... */ });\n```\n\n`walk` returns an [event emitter][eventemitter]\nand asynchronously walks\na stream of JSON data,\nemitting events\nas it encounters\ntokens.\n\nIt takes two arguments;\na [readable stream][readable]\nfrom which\nthe JSON\nwill be read\nand an [options](#options-for-parsing-functions) object.\n\nThe emitted events\nare defined\nas public properties\nof an object,\n`bfj.events`:\n\n* `bfj.events.array`\n  indicates that\n  an array context\n  has been entered\n  by encountering\n  the `[` character.\n\n* `bfj.events.endArray`\n  indicates that\n  an array context\n  has been left\n  by encountering\n  the `]` character.\n\n* `bfj.events.object`\n  indicates that\n  an object context\n  has been entered\n  by encountering\n  the `{` character.\n\n* `bfj.events.endObject`\n  indicates that\n  an object context\n  has been left\n  by encountering\n  the `}` character.\n\n* `bfj.events.property`\n  indicates that\n  a property\n  has been encountered\n  in an object.\n  The listener\n  will be passed\n  the name of the property\n  as its argument\n  and the next event\n  to be emitted\n  will represent\n  the property's value.\n\n* `bfj.events.string`\n  indicates that\n  a string\n  has been encountered.\n  The listener\n  will be passed\n  the value\n  as its argument.\n\n* `bfj.events.number`\n  indicates that\n  a number\n  has been encountered.\n  The listener\n  will be passed\n  the value\n  as its argument.\n\n* `bfj.events.literal`\n  indicates that\n  a JSON literal\n  (either `true`, `false` or `null`)\n  has been encountered.\n  The listener\n  will be passed\n  the value\n  as its argument.\n\n* `bfj.events.error`\n  indicates that\n  an error has occurred.\n  The error may be due to\n  invalid syntax on the incoming stream\n  or caught from one of the event handlers\n  in user code.\n  The listener\n  will be passed\n  the `Error` instance\n  as its argument.\n\n* `bfj.events.end`\n  indicates that\n  the end of the input\n  has been reached\n  and the stream is closed.\n\n### bfj.eventify (data, options)\n\n```js\nconst bfj = require('bfj');\n\nconst emitter = bfj.eventify(data, options);\n\nemitter.on(bfj.events.array, () => { /* ... */ });\nemitter.on(bfj.events.object, () => { /* ... */ });\nemitter.on(bfj.events.property, name => { /* ... */ });\nemitter.on(bfj.events.string, value => { /* ... */ });\nemitter.on(bfj.events.number, value => { /* ... */ });\nemitter.on(bfj.events.literal, value => { /* ... */ });\nemitter.on(bfj.events.endArray, () => { /* ... */ });\nemitter.on(bfj.events.endObject, () => { /* ... */ });\nemitter.on(bfj.events.error, () => { /* ... */ });\nemitter.on(bfj.events.end, () => { /* ... */ });\n```\n\n`eventify` returns an [event emitter][eventemitter]\nand asynchronously traverses\na data structure depth-first,\nemitting events as it\nencounters items.\nBy default it coerces\npromises, buffers and iterables\nto JSON-friendly values.\n\nIt takes two arguments;\nthe data structure to traverse\nand an [options](#options-for-serialisation-functions) object.\n\nThe emitted events\nare defined\nas public properties\nof an object,\n`bfj.events`:\n\n* `bfj.events.array`\n  indicates that\n  an array\n  has been encountered.\n\n* `bfj.events.endArray`\n  indicates that\n  the end of an array\n  has been encountered.\n\n* `bfj.events.object`\n  indicates that\n  an object\n  has been encountered.\n\n* `bfj.events.endObject`\n  indicates that\n  the end of an object\n  has been encountered.\n\n* `bfj.events.property`\n  indicates that\n  a property\n  has been encountered\n  in an object.\n  The listener\n  will be passed\n  the name of the property\n  as its argument\n  and the next event\n  to be emitted\n  will represent\n  the property's value.\n\n* `bfj.events.string`\n  indicates that\n  a string\n  has been encountered.\n  The listener\n  will be passed\n  the value\n  as its argument.\n\n* `bfj.events.number`\n  indicates that\n  a number\n  has been encountered.\n  The listener\n  will be passed\n  the value\n  as its argument.\n\n* `bfj.events.literal`\n  indicates that\n  a JSON literal\n  (either `true`, `false` or `null`)\n  has been encountered.\n  The listener\n  will be passed\n  the value\n  as its argument.\n\n* `bfj.events.error`\n  indicates that\n  an error has occurred.\n  The error may be due to\n  a circular reference\n  encountered in the data\n  or caught from one of the event handlers\n  in user code.\n  The listener\n  will be passed\n  the `Error` instance\n  as its argument.\n\n* `bfj.events.end`\n  indicates that\n  the end of the data\n  has been reached and\n  no further events\n  will be emitted.\n\n## What options can I specify?\n\n### Options for parsing functions\n\n* `options.reviver`:\n  Transformation function,\n  invoked depth-first\n  against the parsed\n  data structure.\n  This option\n  is analagous to the\n  [reviver parameter for JSON.parse][reviver].\n\n* `options.yieldRate`:\n  The number of data items to process\n  before yielding to the event loop.\n  Smaller values yield to the event loop more frequently,\n  meaning less time will be consumed by bfj per tick\n  but the overall parsing time will be slower.\n  Larger values yield to the event loop less often,\n  meaning slower tick times but faster overall parsing time.\n  The default value is `16384`.\n\n* `options.Promise`:\n  Promise constructor that will be used\n  for promises returned by all methods.\n  If you set this option,\n  please be aware that some promise implementations\n  (including native promises)\n  may cause your process to die\n  with out-of-memory exceptions.\n  Defaults to [bluebird's implementation][promise],\n  which does not have that problem.\n\n### Options for serialisation functions\n\n* `options.space`:\n  Indentation string\n  or the number of spaces\n  to indent\n  each nested level by.\n  This option\n  is analagous to the\n  [space parameter for JSON.stringify][space].\n\n* `options.promises`:\n  By default,\n  promises are coerced\n  to their resolved value.\n  Set this property\n  to `'ignore'`\n  for improved performance\n  if you don't need\n  to coerce promises.\n\n* `options.buffers`:\n  By default,\n  buffers are coerced\n  using their `toString` method.\n  Set this property\n  to `'ignore'`\n  for improved performance\n  if you don't need\n  to coerce buffers.\n\n* `options.maps`:\n  By default,\n  maps are coerced\n  to plain objects.\n  Set this property\n  to `'ignore'`\n  for improved performance\n  if you don't need\n  to coerce maps.\n\n* `options.iterables`:\n  By default,\n  other iterables\n  (i.e. not arrays, strings or maps)\n  are coerced\n  to arrays.\n  Set this property\n  to `'ignore'`\n  for improved performance\n  if you don't need\n  to coerce iterables.\n\n* `options.circular`:\n  By default,\n  circular references\n  will cause the write\n  to fail.\n  Set this property\n  to `'ignore'`\n  if you'd prefer\n  to silently skip past\n  circular references\n  in the data.\n\n* `options.bufferLength`:\n  The length of the write buffer.\n  Smaller values use less memory\n  but may result in a slower serialisation time.\n  The default value is `1024`.\n\n* `options.yieldRate`:\n  The number of data items to process\n  before yielding to the event loop.\n  Smaller values yield to the event loop more frequently,\n  meaning less time will be consumed by bfj per tick\n  but the overall serialisation time will be slower.\n  Larger values yield to the event loop less often,\n  meaning slower tick times but faster overall serialisation time.\n  The default value is `16384`.\n\n* `options.Promise`:\n  Promise constructor that will be used\n  for promises returned by all methods.\n  If you set this option,\n  please be aware that some promise implementations\n  (including native promises)\n  may cause your process to die\n  with out-of-memory exceptions.\n  Defaults to [bluebird's implementation][promise],\n  which does not have that problem.\n\n## Why does it default to bluebird promises?\n\nUntil version `4.2.4`,\nnative promises were used.\nBut they were found\nto cause out-of-memory errors\nwhen serialising large amounts of data to JSON,\ndue to [well-documented problems\nwith the native promise implementation](https://alexn.org/blog/2017/10/11/javascript-promise-leaks-memory.html).\nSo in version `5.0.0`,\nbluebird promises were used instead.\nIn version `5.1.0`,\nan option was added\nthat enables callers to specify\nthe promise constructor to use.\nUse it at your own risk.\n\n## Can I specify a different promise implementation?\n\nYes.\nJust pass the `Promise` option\nto any method.\nIf you get out-of-memory errors\nwhen using that option,\nconsider changing your promise implementation.\n\n## Is there a change log?\n\n[Yes][history].\n\n## How do I set up the dev environment?\n\nThe development environment\nrelies on [Node.js][node],\n[ESLint],\n[Mocha],\n[Chai],\n[Proxyquire] and\n[Spooks].\nAssuming that\nyou already have\nnode and NPM\nset up,\nyou just need\nto run\n`npm install`\nto install\nall of the dependencies\nas listed in `package.json`.\n\nYou can\nlint the code\nwith the command\n`npm run lint`.\n\nYou can\nrun the tests\nwith the command\n`npm test`.\n\n## What versions of Node.js does it support?\n\nVersions 4 and later.\n\n## What license is it released under?\n\n[MIT][license].\n\n[ci-image]: https://secure.travis-ci.org/philbooth/bfj.png?branch=master\n[ci-status]: http://travis-ci.org/#!/philbooth/bfj\n[sax]: http://en.wikipedia.org/wiki/Simple_API_for_XML\n[promise]: http://bluebirdjs.com/docs/api-reference.html\n[eventemitter]: https://nodejs.org/api/events.html#events_class_eventemitter\n[readable]: https://nodejs.org/api/stream.html#stream_readable_streams\n[writable]: https://nodejs.org/api/stream.html#stream_writable_streams\n[pipe]: https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n[reviver]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter\n[space]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_space_argument\n[history]: HISTORY.md\n[node]: https://nodejs.org/en/\n[eslint]: http://eslint.org/\n[mocha]: https://mochajs.org/\n[chai]: http://chaijs.com/\n[proxyquire]: https://github.com/thlorenz/proxyquire\n[spooks]: https://github.com/philbooth/spooks.js\n[license]: COPYING\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/philbooth/bfj.git"
  },
  "scripts": {
    "integration": "mocha --ui tdd --reporter spec --colors test/integration",
    "lint": "eslint src",
    "perf": "wget -O test/mtg.json http://mtgjson.com/json/AllSets-x.json && node test/performance mtg",
    "test": "npm run unit && npm run integration",
    "unit": "mocha --ui tdd --reporter spec --recursive --colors --slow 120 test/unit"
  },
  "version": "5.2.1"
}
